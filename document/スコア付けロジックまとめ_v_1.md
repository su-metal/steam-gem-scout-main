# スコア付けロジックまとめ（2025-12-04 時点）

## 1. 全体フロー概要

1. **game_rankings_cache** テーブルから候補ゲームを取得
2. 各ゲームごとに以下を持っている：
   - `data`（元データ JSON）
   - `price`, `price_original`, `discount_percent`
   - `mood_scores`（mood.ts で事前計算済みの 5 軸スコア）
   - `tags`（AI 解析で生成した AI タグ。Steam タグよりこちらを優先）
3. search-games 関数内で：
   - 事前フィルタ（レビュー数・プレイ時間・期間・AIタグなど）
   - スコア計算（baseScore + moodScore）
   - ソート（recommended / price / date など）


---
## 2. mood_scores の生成ロジック（mood.ts 側）

### 2-1. 5 軸

- `operation` … 操作感・アクション性
- `session` … セッション長・遊び方のリズム
- `tension` … 緊張感・ホラー度・激しさ
- `story` … 物語性・キャラドラマ
- `brain` … 思考負荷・戦略性

### 2-2. タグ → 生ムード値（RawMood）

1. Steam タグや genre を元に、`TAG_TO_MOOD` テーブルで **各タグごとの重み** を定義
2. ゲームに付いているタグを走査し、各軸に対して加算していく
   - 例：
     - `"Story Rich"` → `story +2.0`
     - `"Visual Novel"` → `story +2.5`
     - `"Sports"` → `story -2.0`, `operation +1.5`
     - `"Racing"` → `story -2.2`, `operation +1.8`, `tension +1.5`
     - `"Battle Royale"` など対戦専 → `story` に強めのマイナス
3. これで **生のベクトル（RawMood）** を得る。


### 2-3. 正規化（RawMood → MoodVector）

- 各軸ごとに `-maxAbs 〜 +maxAbs` を **0〜1 に線形マップ**
- `maxAbs` は軸ごとのスケール（例：`AXIS_SCALE.story = 3.0`）
- マッピング式：
  
  ```ts
  out[k] = (v + maxAbs) / (2 * maxAbs); // v: 生値
  ```

- その結果：
  - v = 0 → out = 0.5（ニュートラル）
  - v がマイナスに大きい → 0 〜 0.3 くらい
  - v がプラスに大きい → 0.7 〜 1.0 くらい

### 2-4. AI 解析による補正（applyAiMoodAdjustment）

- レビュー要約や pros/cons などを連結したテキストから **キーワード検出**
- 例：Story 軸
  - `"ストーリーほとんどない"` / `"物語が薄い"` / `"no real story"` など → `story -0.25`
  - `"物語が良い"` / `"ストーリー重視"` / `"story-rich"` など → `story +0.18`
  - `"キャラクター"` / `"ドラマ"` など → `story +0.07`
- 同様に、ホラー・緊張感ワードで `tension` を上げるなど、各軸を微調整。

### 2-5. Sports / Racing / 対戦専の Story ペナルティ

- `TAG_TO_MOOD` 内で、以下のようなタグに対して **強い story マイナスを付与**：
  - `Sports`, `Soccer`, `Football`, `Basketball`, `Baseball`
  - `Racing`, `Racing Sim`, `Driving`, `Car Racing`, `Motorsport`
  - `Battle Royale`, `MOBA`, `Arena Shooter`, `Online PvP`, `Party Game` など
- 正規化後は `story ≒ 0.1〜0.3` 程度になり、Narrative プリセットでは大きく不利になる。


---
## 3. search-games 側のスコア計算

### 3-1. データのマッピング

Supabase から取った行を、内部用のゲームオブジェクトに変換：

- `base = row.data`（元の JSON）
- `price`, `price_original`, `discount_percent` を物理カラム優先で上書き
- `tags`（AIタグ）
  - `game_rankings_cache.tags`（AIタグ）
  - `base.tags`（旧: Steamタグ）
  - 2 つをマージし、**AIタグ優先**で重複除去
  - `g.tags` にマージ結果、`g.aiTags` に AIタグのみを保持

この `g` をベースに、以降のフィルタ・スコア計算を実行する。


### 3-2. 事前フィルタ

1. **ジャンル / タグ フィルタ**
   - `genre`（簡易キーワード）が指定されていれば、`g.tags` に含まれるかでフィルタ
2. **AIタグフィルタ（新規追加）**
   - `body.aiTags: string[]` が指定されていれば：
     - `g.aiTags`（なければ `g.tags`）に対して
     - `aiTagsFilter.every(tag => tags に含まれる)` で AND 条件フィルタ
3. **レビュー数フィルタ**
   - `minReviews` 未満のタイトルを除外
4. **プレイ時間フィルタ**
   - `minPlaytime` 未満のタイトルを除外
5. **期間フィルタ（recentDays）**
   - リファレンス日（最近のレビュー日 or リリース日）から N 日以内かどうか


### 3-3. baseScore（品質スコア）

`computeScore(g, isCustom)` で計算。

- インプット：
  - レビュー数、ポジティブ率、AI評価、リリースの新しさなど
- 出力：
  - だいたい 0〜10 の範囲のスコア（`compositeScore`）

ソート種別 `custom` のときはそのまま利用、それ以外は 0〜1 に正規化：

```ts
const normalizedBase = isCustom
  ? compositeScore
  : compositeScore / 10;
```


### 3-4. moodScore（気分マッチスコア）

`calcMoodMatchScore(game.moodScores, userMood)` で計算。

1. **重みプロファイルの取得**

   - デフォルト：

     ```ts
     MOOD_WEIGHTS_DEFAULT = {
       operation: 1.1,
       session: 0.9,
       tension: 1.1,
       story: 0.8,
       brain: 0.9,
     };
     ```

   - ストーリー重視モード（ユーザーの `story` スライダーが高く、他軸より十分高い場合）：

     ```ts
     MOOD_WEIGHTS_STORY_FOCUSED = {
       operation: 0.5,
       session: 0.6,
       tension: 0.6,
       story: 2.4,
       brain: 0.8,
     };
     ```

2. **距離計算**

   - 各軸ごとに：

     ```ts
     diff = gameAxis - userAxis;
     sum += weight * diff * diff;
     weightSum += weight;
     ```

   - `sum / weightSum` の平方根を距離として、`distanceToScore` で 0〜1 のスコアに変換
   - 距離が小さいほどスコアが高くなる（= 気分に合う）

3. **ストーリー重視モード＋低ストーリージャンルへのペナルティ**

   - `storyFocused == true` のとき、かつ：
     - `g.moodScores.story < 0.45`
     - `isLowStoryGenreGame(g)`（Sports / Racing / 対戦専 / Party など）
   - の条件を満たすゲームに対して：

     ```ts
     moodScore *= 0.3; // 70% 減
     ```

   - これにより、Narrative プリセットでスポーツゲームなどが上位に来にくくなる。


### 3-5. finalScore（最終スコア）

`calcFinalRankingScore(base, mood)` で `baseScore` と `moodScore` を合成：

```ts
const BASE_WEIGHT = 0.3;
const MOOD_WEIGHT = 0.7;

const finalNormalized = userMood
  ? BASE_WEIGHT * normalizedBase + MOOD_WEIGHT * moodScore
  : normalizedBase;
```

- 気分マッチをかなり重視（70%）しつつ、品質スコアも 30% だけ効かせる構成
- `finalCompositeScore = finalNormalized * 10` として 0〜10 に戻して UI 表示などに利用。


---
## 4. AIタグの活用ポイント

### 4-1. データとしての扱い

- `game_rankings_cache.tags` カラムに AIタグを保存
- search-games のマッピングで：
  - `g.aiTags` に AIタグ（配列）
  - `g.tags` に AIタグ＋旧 tags のマージ済み配列（AI優先）

### 4-2. フィルタとしての利用

- SearchBody に `aiTags?: string[]` を追加
- `body.aiTags` が指定されている場合、
  - `g.aiTags`（なければ `g.tags`）にその全てが含まれるゲームだけを残す（AND 条件）
  - OR 条件に変えることも可能（`some` にするだけ）

### 4-3. 今後の拡張余地

- プリセットごとに「AIタグ必須条件」を決める：
  - 例：Narrative プリセット → `aiTags` に `"物語重視"` などを含む
- スコアリングへの軽い加点・減点：
  - 例：`"デッキ構築"` タグがあれば、Deckbuilder プリセットで `moodScore` に+α


---
## 5. 現時点でのチューニングの狙い

- **Narrative（Story）系の気分で検索したときに**：
  - スポーツやレース、競技専用ゲームが高 MATCH で出てこないようにする
  - Story Rich / Visual Novel / JRPG / Narrative 系タイトルがきちんと上位に来る
- そのために：
  - mood.ts 側で **Sports / Racing / 対戦専の Story 値を強く下げる**
  - AI解析で「ストーリーがほとんどない」レビューを検知して story をマイナス補正
  - search-games 側で **ストーリー重視モードのときに Story 軸の重みを最大化**
  - さらに **低ストーリージャンルにペナルティ** をかけて漏れを減らす
  - AIタグを使ったフィルタで、より意味のある候補集合を作る

このロジックをベースに、今後はプリセットごと（Action / Cozy / Brainy など）の重み・AIタグ利用を増やしていく想定です。
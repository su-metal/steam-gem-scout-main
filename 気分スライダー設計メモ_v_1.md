# 気分スライダー（Vibe Sliders）設計まとめ

## 1. 目的

- ユーザーが「細かい条件指定なし」で、その日の気分に合うゲーム候補を素早く絞り込める UI を提供する。
- スライダー操作だけで **ゲーム体験ベクトル × ユーザー気分ベクトル** のマッチングを行う。
- 解析コストを抑えるため、**AI 解析に依存しないベースロジック**を用意し、AI は「補正＆リッチ化」に使う。

---

## 2. スライダー構成（最終イメージ）

### 2.1 メイン 3 軸（常時表示）

ユーザーが必ず目にする「気分」のコアとなる 3 本。

1. **操作量軸**

   - 英: `Passive  ↔ Active`
   - 日: `ゆったり ←→ アクション多め`（候補）
   - 意味: 手の忙しさ・操作量・テンポ感。
   - 左: クリック少なめ / 眺める・置きゲー寄り。
   - 右: 常に操作していたい / アクション・シューティング寄り。

2. **セッション長軸**

   - 英: `Short-burst  ↔ Long-session`（UI 上は Short ↔ Long で OK）
   - 日: `短め ←→ 長め`
   - 意味: 1 プレイの所要時間。短時間で一区切りか、腰を据えて遊ぶか。

3. **テンション軸（精神的負荷）**

   - 英: `Cozy  ↔ Intense`
   - 日: `癒やし ←→ 緊張感`（もしくは `リラックス ←→ 緊張・スリル`）
   - 意味: 心のテンション・ストレス度。穏やかな体験か、ドキドキするか。

### 2.2 Advanced Filters 2 軸（詳細設定）

Advanced Filters としてサブカードに表示。初期状態では閉じておき、 「こだわり派」が開いて微調整できる位置づけ。

4. **ストーリー濃度軸**

   - 英: `Play-focused  ↔ Narrative` または `Story-Light ↔ Story-Heavy`
   - 日: `プレイ重視 ←→ ナラティブ`
   - 意味: ゲームプレイと物語の比重。
   - 左: アクション/システム中心。ストーリーは薄めで OK。
   - 右: 物語・キャラクター・会話をじっくり味わう。

5. **思考負荷軸**

   - 英: `Simple  ↔ Deep`（or `Brain-Light ↔ Brain-Heavy`）
   - 日: `シンプル ←→ じっくり`
   - 意味: 頭をどれくらい使うか。直感プレイ vs 戦略/パズル/ビルド思考。
   - 左: ルールが分かりやすく、直感で遊べる。
   - 右: 戦略・計画・パズル的思考が楽しいゲーム。

---

## 3. UI レイアウト方針

### 3.1 デスクトップ

- カード全体は中央寄せ・最大幅 \~980px。
- カード内部は左右 2 カラム構成。
  - **左カラム（vibe-main）**
    - 説明文（"今日の気分を3つだけ調整"）。
    - メイン 3 本のスライダー。
    - 「詳細な気分調整（＋2軸）」トグルボタン。
  - **右カラム（vibe-advanced-panel）**
    - Advanced Filters の小さなサブカード。
    - チップ: `Advanced Filters`。
    - 説明文 + Advanced 2 本のスライダー。
- Advanced が閉じているときは、小カードごとフェードアウト（opacity 0, pointer-events none）。

### 3.2 モバイル

- `.vibe-layout` を 1 カラムにし、
  - 上: メイン 3 本
  - 下: Advanced カード という縦並びにする。
- スライダー間隔はやや詰め、トグルボタンは上部に。

---

## 4. 内部ロジック設計（AI なしのベース）

### 4.1 ゲームの「気分ベクトル」

各ゲームは、以下 5 次元のベクトルを持つ。

```ts
// 0〜1 の正規化値で保存する想定
interface MoodVector {
  operation: number;   // 操作量: Passive (0) ↔ Active (1)
  session: number;     // セッション長: Short (0) ↔ Long (1)
  tension: number;     // テンション: Cozy (0) ↔ Intense (1)
  story: number;       // ストーリー濃度: Play-focused (0) ↔ Narrative (1)
  brain: number;       // 思考負荷: Simple (0) ↔ Deep (1)
}
```

### 4.2 データソース

AI を使わず、Steam メタデータから計算可能な項目を使う：

- Steam タグ / ジャンル
- 協力 / 対戦 / Single / Multi 等
- レビュー数・ポジティブ率
- 平均プレイ時間（あれば）

基本は **タグ → 気分軸の重みテーブル**で実現する。

### 4.3 タグ → 気分軸の重みテーブル（概念）

```ts
type MoodSliderId = "operation" | "session" | "tension" | "story" | "brain";

type TagWeights = Partial<Record<MoodSliderId, number>>;

const TAG_TO_MOOD: Record<string, TagWeights> = {
  // 操作量
  "Action":       { operation: 0.9 },
  "Shooter":      { operation: 1.0, tension: 0.3 },
  "Souls-like":   { operation: 1.0, brain: 0.4, tension: 0.8, session: 0.7 },

  // セッション長
  "Roguelite":    { session: 0.3, operation: 0.5, brain: 0.3 },
  "JRPG":         { session: 0.8, story: 0.7, brain: 0.4 },
  "Grand Strategy": { session: 0.9, brain: 1.0 },

  // テンション
  "Relaxing":     { tension: 0.0, operation: -0.4 },
  "Horror":       { tension: 1.0 },
  "Survival":     { tension: 0.8, brain: 0.4 },

  // ストーリー
  "Story Rich":   { story: 1.0 },
  "Visual Novel": { story: 1.0, operation: -0.6 },

  // 思考負荷
  "Strategy":     { brain: 1.0 },
  "Puzzle":       { brain: 0.8 },
  "City Builder": { brain: 0.7, session: 0.6 },

  // Cozy 系
  "Farming Sim":  { tension: 0.1, story: 0.4, brain: 0.3 },
  "Wholesome":    { tension: 0.1 },
};
```

- 値のレンジはだいたい `-1.0〜+1.0` を想定。
- 同一ゲーム内の複数タグを合算し、あとで正規化する。

### 4.4 ゲーム側ベクトル計算

```ts
const EMPTY: MoodVector = {
  operation: 0,
  session: 0,
  tension: 0,
  story: 0,
  brain: 0,
};

function calcRawMood(tags: string[]): MoodVector {
  const scores: Record<MoodSliderId, number> = { ...EMPTY } as any;

  for (const tag of tags) {
    const w = TAG_TO_MOOD[tag];
    if (!w) continue;

    for (const key of Object.keys(w) as MoodSliderId[]) {
      scores[key] += w[key]!;
    }
  }

  return scores as MoodVector;
}

function normalizeMood(raw: MoodVector): MoodVector {
  const out: MoodVector = { ...EMPTY };
  (Object.keys(raw) as MoodSliderId[]).forEach((k) => {
    const v = Math.max(-3, Math.min(3, raw[k])); // -3〜+3 にクリップ
    out[k] = (v + 3) / 6;                        // 0〜1 に変換
  });
  return out;
}
```

この `normalizeMood` の結果を DB に `mood_scores` のような JSON カラムで保存しておく。

---

## 5. ユーザー入力とのマッチング

### 5.1 ユーザー側ベクトル

- スライダー入力値は 0〜4 の 5 段階。
- 保存・送信用は 0〜1 に正規化して扱う。

```ts
interface UserMoodPrefs extends MoodVector {}
```

### 5.2 マッチングスコア計算

単純な「距離」に基づくスコア。

```ts
function calcMoodMatchScore(game: MoodVector, user: UserMoodPrefs): number {
  let score = 0;
  let weightSum = 0;

  (Object.keys(game) as MoodSliderId[]).forEach((k) => {
    const w = 1; // 軸ごとの重要度を変えたくなったらここを調整
    const diff = Math.abs(game[k] - user[k]); // 0〜1
    score += w * (1 - diff); // diff 0 → 1点, diff 1 → 0点
    weightSum += w;
  });

  return weightSum > 0 ? score / weightSum : 0; // 0〜1
}
```

- `calcMoodMatchScore` が高いゲームほど「今の気分に合う」。
- ランキング API では
  - `matchScore` を降順ソート
  - 一定値以下（例: 0.4 未満）は候補から除外 などに使う。

---

## 6. AI 解析との統合方針（最新版）

### 6.1 役割の切り分け

- **ベースロジック**：Steam タグ → `TAG_TO_MOOD` → `calcRawMood` → `normalizeMood` で 5 軸のベースベクトルをつくる（全タイトル対象、AI 不要）。
- **AI ロジック**：`analysis` JSON（hidden gem 解析結果）から、体験のニュアンスを読み取り、ベースベクトルを ±0.1〜0.25 程度で「補正」する。
- これにより、
  - タグだけでは分かりにくい **Cozy / Intense** や **Story-heavy / Brain-heavy** のニュアンスを AI で反映
  - 追加の API コールは不要（既存の analysis を再利用）

### 6.2 型とヘルパーの構成

```ts
// 既存
export type MoodSliderId = "operation" | "session" | "tension" | "story" | "brain";
export interface MoodVector {
  operation: number;
  session: number;
  tension: number;
  story: number;
  brain: number;
}

// AI 解析から、気分補正に使う最小限の構造だけを定義
export interface MoodAnalysisLike {
  summary?: string;
  pros?: string[];
  cons?: string[];
  labels?: string[];
  audiencePositive?: { label?: string; description?: string }[];
  audienceNegative?: { label?: string; description?: string }[];
}
```

### 6.3 補正ロジックの流れ

1. `calcRawMood(tags)` でタグベースの生スコアをつくる。
2. `normalizeMood(raw)` で 0〜1 に正規化したベースベクトルを得る。
3. `applyAiMoodAdjustment(base, analysis)` で AI 解析情報に応じて 5 軸を少しだけ増減させる。
4. 最終的なスコアは `buildMoodFromTagsAndAnalysis(tags, analysis)` から取得する。

```ts
function buildAnalysisText(a?: MoodAnalysisLike | null): string { /* summary / pros / cons / labels 等を全部くっつけて lowerCase  */ }

function bumpAxis(v: MoodVector, key: MoodSliderId, delta: number) {
  const next = v[key] + delta;
  v[key] = Math.max(0, Math.min(1, next)); // 0〜1 にクリップ
}

export function applyAiMoodAdjustment(base: MoodVector, analysis?: MoodAnalysisLike | null): MoodVector {
  if (!analysis) return base;
  const text = buildAnalysisText(analysis);
  if (!text) return base;

  const out: MoodVector = { ...base };

  // Story 濃度
  if (/(物語重視|ストーリー重視|物語|ストーリー|narrative|story[- ]rich)/.test(text)) {
    bumpAxis(out, "story", 0.18);
  }
  if (/(キャラ|キャラクター|会話|ドラマ)/.test(text)) {
    bumpAxis(out, "story", 0.07);
  }

  // テンション（Cozy ↔ Intense）
  if (/(ホラー|恐怖|スリル|緊張感|サバイバル|心臓に悪い|びっくり|jumpscare|intense|tense)/.test(text)) {
    bumpAxis(out, "tension", 0.22);
  }
  if (/(まったり|癒し|ゆったり|リラックス|chill|cozy|のんびり)/.test(text)) {
    bumpAxis(out, "tension", -0.22);
  }

  // 操作量（Passive ↔ Active）
  if (/(アクション|爽快|テンポが速い|スピーディ|忙しい操作|コンボ|連打|dodgeroll|bullet hell)/.test(text)) {
    bumpAxis(out, "operation", 0.18);
  }
  if (/(放置|眺める|idle|オートプレイ|自動で進む)/.test(text)) {
    bumpAxis(out, "operation", -0.18);
  }

  // 思考負荷（Simple ↔ Deep）
  if (/(戦略|ストラテジー|タクティクス|戦術|パズル|頭を使う|思考|ビルド構築|デッキ構築|tactical|strategy|planning)/.test(text)) {
    bumpAxis(out, "brain", 0.22);
  }
  if (/(単純|シンプル|気軽|カジュアル|難しくない)/.test(text)) {
    bumpAxis(out, "brain", -0.15);
  }

  // セッション長（Short ↔ Long）
  if (/(短時間|サクッと|スキマ時間|1時間程度|30分程度|ショートセッション|short session|bite[- ]sized)/.test(text)) {
    bumpAxis(out, "session", -0.18);
  }
  if (/(長時間|腰を据えて|ボリューム|周回プレイ|やり込み|何十時間|長く遊べる|long session)/.test(text)) {
    bumpAxis(out, "session", 0.18);
  }

  return out;
}

export function buildMoodFromTagsAndAnalysis(tags: string[], analysis?: MoodAnalysisLike | null): MoodVector {
  const raw = calcRawMood(tags);
  const base = normalizeMood(raw);
  return applyAiMoodAdjustment(base, analysis);
}
```

### 6.4 search-games / import-steam-games からの利用パターン

- **import-steam-games**
  - Steam から取得した `tags` と、もしあれば `analysis` を渡して
    `mood_scores = buildMoodFromTagsAndAnalysis(tags, analysis)` を保存。
  - 解析未実施タイトルは `analysis` なしで呼び出し → タグベースのみのスコア。

- **backfill-mood-scores**
  - 既存の `game_rankings_cache` / `steam_games` を走査し、
    - analysis がある行：`buildMoodFromTagsAndAnalysis(tags, analysis)`
    - analysis がない行：`buildMoodFromTagsAndAnalysis(tags)`
    で mood_scores を再計算して保存。

- **search-games**
  - DB から `mood_scores` を読んで、ユーザーの `userMood` と `calcMoodMatchScore` でマッチ度を計算。
  - ソートモード `Mood Match` では `finalScore = 0.6 * baseScore + 0.4 * moodMatch` などのブレンドでランキング。

### 6.5 この設計のメリット

- 全タイトルに対して **タグベースで 5 軸ベクトル**を持てる（気分検索の土台）。
- AI 解析済みタイトルは、レビュー本文のニュアンスに応じて **0.15〜0.25 程度の補正**が入り、
  - ホラー → tension / operation が上がる
  - Cozy ゲー → tension が下がる
  - 物語重視 → story が上がる
  - 戦略・パズル → brain / session が上がる
  など、体験の違いが 5 軸上に反映される。
- 追加の OpenAI 呼び出しは不要で、**既存の analysis JSON だけで精度アップ**できる。
- MVP の段階ではこの仕組みで十分な精度を出しつつ、将来的には
  - 「気分専用の軽量解析（nano）」
  - 「ユーザー履歴からの好みベクトル学習」
 などを上乗せする余地がある。

---

## 7. 今後の検討ポイント

- 各軸の閾値や補正量（±0.15〜0.25）の調整。
- 実タイトル数十本でサンプルを取り、
  - タグのみのスコア
  - タグ + AI 補正後のスコア
  - 実際の体感（このゲームはどの位置にいるべきか）
  を比較してパラメータチューニング。
- Quick Filters（"アクション × 短時間" 等）を 5 次元ベクトルのプリセットとして定義し、
  気分フィルターと同じロジックで検索にかける。


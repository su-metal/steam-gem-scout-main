# 気分スライダー（Vibe Sliders）設計まとめ

## 1. 目的

- ユーザーが「細かい条件指定なし」で、その日の気分に合うゲーム候補を素早く絞り込める UI を提供する。
- スライダー操作だけで **ゲーム体験ベクトル × ユーザー気分ベクトル** のマッチングを行う。
- 解析コストを抑えるため、**AI 解析に依存しないベースロジック**を用意し、AI は「補正＆リッチ化」に使う。

---

## 2. スライダー構成（最終イメージ）

### 2.1 メイン 3 軸（常時表示）

ユーザーが必ず目にする「気分」のコアとなる 3 本。

1. **操作量軸**

   - 英: `Passive  ↔ Active`
   - 日: `ゆったり ←→ アクション多め`（候補）
   - 意味: 手の忙しさ・操作量・テンポ感。
   - 左: クリック少なめ / 眺める・置きゲー寄り。
   - 右: 常に操作していたい / アクション・シューティング寄り。

2. **セッション長軸**

   - 英: `Short-burst  ↔ Long-session`（UI 上は Short ↔ Long で OK）
   - 日: `短め ←→ 長め`
   - 意味: 1 プレイの所要時間。短時間で一区切りか、腰を据えて遊ぶか。

3. **テンション軸（精神的負荷）**

   - 英: `Cozy  ↔ Intense`
   - 日: `癒やし ←→ 緊張感`（もしくは `リラックス ←→ 緊張・スリル`）
   - 意味: 心のテンション・ストレス度。穏やかな体験か、ドキドキするか。

### 2.2 Advanced Filters 2 軸（詳細設定）

Advanced Filters としてサブカードに表示。初期状態では閉じておき、 「こだわり派」が開いて微調整できる位置づけ。

4. **ストーリー濃度軸**

   - 英: `Play-focused  ↔ Narrative` または `Story-Light ↔ Story-Heavy`
   - 日: `プレイ重視 ←→ ナラティブ`
   - 意味: ゲームプレイと物語の比重。
   - 左: アクション/システム中心。ストーリーは薄めで OK。
   - 右: 物語・キャラクター・会話をじっくり味わう。

5. **思考負荷軸**

   - 英: `Simple  ↔ Deep`（or `Brain-Light ↔ Brain-Heavy`）
   - 日: `シンプル ←→ じっくり`
   - 意味: 頭をどれくらい使うか。直感プレイ vs 戦略/パズル/ビルド思考。
   - 左: ルールが分かりやすく、直感で遊べる。
   - 右: 戦略・計画・パズル的思考が楽しいゲーム。

---

## 3. UI レイアウト方針

### 3.1 デスクトップ

- カード全体は中央寄せ・最大幅 \~980px。
- カード内部は左右 2 カラム構成。
  - **左カラム（vibe-main）**
    - 説明文（"今日の気分を3つだけ調整"）。
    - メイン 3 本のスライダー。
    - 「詳細な気分調整（＋2軸）」トグルボタン。
  - **右カラム（vibe-advanced-panel）**
    - Advanced Filters の小さなサブカード。
    - チップ: `Advanced Filters`。
    - 説明文 + Advanced 2 本のスライダー。
- Advanced が閉じているときは、小カードごとフェードアウト（opacity 0, pointer-events none）。

### 3.2 モバイル

- `.vibe-layout` を 1 カラムにし、
  - 上: メイン 3 本
  - 下: Advanced カード という縦並びにする。
- スライダー間隔はやや詰め、トグルボタンは上部に。

---

## 4. 内部ロジック設計（AI なしのベース）

### 4.1 ゲームの「気分ベクトル」

各ゲームは、以下 5 次元のベクトルを持つ。

```ts
// 0〜1 の正規化値で保存する想定
interface MoodVector {
  operation: number;   // 操作量: Passive (0) ↔ Active (1)
  session: number;     // セッション長: Short (0) ↔ Long (1)
  tension: number;     // テンション: Cozy (0) ↔ Intense (1)
  story: number;       // ストーリー濃度: Play-focused (0) ↔ Narrative (1)
  brain: number;       // 思考負荷: Simple (0) ↔ Deep (1)
}
```

### 4.2 データソース

AI を使わず、Steam メタデータから計算可能な項目を使う：

- Steam タグ / ジャンル
- 協力 / 対戦 / Single / Multi 等
- レビュー数・ポジティブ率
- 平均プレイ時間（あれば）

基本は **タグ → 気分軸の重みテーブル**で実現する。

### 4.3 タグ → 気分軸の重みテーブル（概念）

```ts
type MoodSliderId = "operation" | "session" | "tension" | "story" | "brain";

type TagWeights = Partial<Record<MoodSliderId, number>>;

const TAG_TO_MOOD: Record<string, TagWeights> = {
  // 操作量
  "Action":       { operation: 0.9 },
  "Shooter":      { operation: 1.0, tension: 0.3 },
  "Souls-like":   { operation: 1.0, brain: 0.4, tension: 0.8, session: 0.7 },

  // セッション長
  "Roguelite":    { session: 0.3, operation: 0.5, brain: 0.3 },
  "JRPG":         { session: 0.8, story: 0.7, brain: 0.4 },
  "Grand Strategy": { session: 0.9, brain: 1.0 },

  // テンション
  "Relaxing":     { tension: 0.0, operation: -0.4 },
  "Horror":       { tension: 1.0 },
  "Survival":     { tension: 0.8, brain: 0.4 },

  // ストーリー
  "Story Rich":   { story: 1.0 },
  "Visual Novel": { story: 1.0, operation: -0.6 },

  // 思考負荷
  "Strategy":     { brain: 1.0 },
  "Puzzle":       { brain: 0.8 },
  "City Builder": { brain: 0.7, session: 0.6 },

  // Cozy 系
  "Farming Sim":  { tension: 0.1, story: 0.4, brain: 0.3 },
  "Wholesome":    { tension: 0.1 },
};
```

- 値のレンジはだいたい `-1.0〜+1.0` を想定。
- 同一ゲーム内の複数タグを合算し、あとで正規化する。

### 4.4 ゲーム側ベクトル計算

```ts
const EMPTY: MoodVector = {
  operation: 0,
  session: 0,
  tension: 0,
  story: 0,
  brain: 0,
};

function calcRawMood(tags: string[]): MoodVector {
  const scores: Record<MoodSliderId, number> = { ...EMPTY } as any;

  for (const tag of tags) {
    const w = TAG_TO_MOOD[tag];
    if (!w) continue;

    for (const key of Object.keys(w) as MoodSliderId[]) {
      scores[key] += w[key]!;
    }
  }

  return scores as MoodVector;
}

function normalizeMood(raw: MoodVector): MoodVector {
  const out: MoodVector = { ...EMPTY };
  (Object.keys(raw) as MoodSliderId[]).forEach((k) => {
    const v = Math.max(-3, Math.min(3, raw[k])); // -3〜+3 にクリップ
    out[k] = (v + 3) / 6;                        // 0〜1 に変換
  });
  return out;
}
```

この `normalizeMood` の結果を DB に `mood_scores` のような JSON カラムで保存しておく。

---

## 5. ユーザー入力とのマッチング

### 5.1 ユーザー側ベクトル

- スライダー入力値は 0〜4 の 5 段階。
- 保存・送信用は 0〜1 に正規化して扱う。

```ts
interface UserMoodPrefs extends MoodVector {}
```

### 5.2 マッチングスコア計算

単純な「距離」に基づくスコア。

```ts
function calcMoodMatchScore(game: MoodVector, user: UserMoodPrefs): number {
  let score = 0;
  let weightSum = 0;

  (Object.keys(game) as MoodSliderId[]).forEach((k) => {
    const w = 1; // 軸ごとの重要度を変えたくなったらここを調整
    const diff = Math.abs(game[k] - user[k]); // 0〜1
    score += w * (1 - diff); // diff 0 → 1点, diff 1 → 0点
    weightSum += w;
  });

  return weightSum > 0 ? score / weightSum : 0; // 0〜1
}
```

- `calcMoodMatchScore` が高いゲームほど「今の気分に合う」。
- ランキング API では
  - `matchScore` を降順ソート
  - 一定値以下（例: 0.4 未満）は候補から除外 などに使う。

---

## 6. AI 解析との統合方針

### 6.1 ベースはタグベクトル、AI は「補正」役

- 全タイトルに対しては **タグから計算した **``** をベース**とする。
- AI 解析済みタイトルのみ、レビュー本文・ラベルから補正を入れる：
  - レビューで頻出するワード（"緊張感", "まったり", "ストーリー", "パズル"…）
  - AI が抽出した labels / pros / cons / プレイヤー像 など。

例：

```ts
// AI 解析から補正を追加するイメージ
function applyAiMoodAdjustment(base: MoodVector, analysis: HiddenGemAnalysis): MoodVector {
  const out = { ...base };

  if (analysis.labels?.includes("Cozy")) {
    out.tension = Math.max(0, out.tension - 0.2);
  }
  if (analysis.labels?.includes("High Challenge")) {
    out.tension = Math.min(1, out.tension + 0.2);
  }
  if (analysis.labels?.includes("Story-focused")) {
    out.story = Math.min(1, out.story + 0.2);
  }
  if (analysis.labels?.includes("Strategy")) {
    out.brain = Math.min(1, out.brain + 0.2);
  }

  return out;
}
```

### 6.2 役割の切り分け

- **ベースロジック**: タグとメタデータから自動的に計算 → 全タイトル対象。
- **AI ロジック**: 一部タイトルのみ深掘り解析し、
  - ベースベクトルの微調整
  - GameDetail 用のリッチテキスト（summary / pros / cons / currentState など）を提供。

この構造にすることで：

- アプリ全体としては「数万本規模で気分検索」が可能。
- AI コストは「本当に推したい数百〜千本」だけに限定できる。

---

## 7. 今後の検討ポイント

- 各軸の最終文言（日本語 / 英語）を UI 実物と合わせて微調整。
- Steam の実データを数十タイトル分サンプルに取り、
  - TAG\_TO\_MOOD の重みチューニング
  - 正規化レンジ（-3〜+3）の妥当性
  - ユーザー 0〜4 入力との体感差 を確認する。
- Quick Filters（"アクション × 短時間" 等）のプリセットを、 5 次元ベクトルの組み合わせとして定義する。
- 将来的には「ユーザー履歴から自動で好みベクトルを学習」する余地あり。

---

※ このメモは「設計の土台」としてまとめたもので、実装とテストを経て数値や文言は適宜アップデートしていく。

